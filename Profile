Skill:
    c++/
    c#/
    WPF/
    shell/
    objective-c/
    python/
    WixToolset/
    tomcat/



proj1 WS(2017-07 to 2018-09):
    develop app on Windows and Mac OS.
    develop an app that works as bridge between web client and os application.
    
    Windows: installation file(.msi based on WixToolset) and application file(.exe based on C#)
    Mac: pkg file based on objective-c
    
    Whitelist based on Shell:
        with shell, user can turn on/turn off/add/check/delete/update ips to whitelist which has right to access admin website.
        A shell file contains all functions.
        A command in UI can invoke this file.
        Upgrade will backup and restore datas in iptables.
        .spec -> build .RPM packages(are used for installing Linux programs)
        
        /etc/passwd:
        username:password:user ID:group ID:user ID info:home directory:command/shell
        if password is x character that indicates that encrypted password is stored in /etc/shadow
        
        /etc/shadow:
        username:password:last password change(since 1970-1-1):minimum:maximum:warn:inactive:expire
        
        whitelist.sh
        iptables:
        
        grep:
        
        =~/regular expression:
        
        sed:
        
        awk:
        
        PGPASSWORD=Polycom@12#$ psql -U postgres postgres -c 'select * from ca_wsp.whitelistswitch' > status
        PGPASSWORD=Polycom@12#$ psql -U postgres postgres -qc "update ca_wsp.whitelistswitch set enableflag='0'"
		PGPASSWORD=Polycom@12#$	psql -U postgres postgres -qc "delete from ca_wsp.whitelistconfig where subnet like '%$IP%'"

        $@: stores all the arguments in a list of string
        $*: stores all the arguments as a single string
        $#: stores the number of arguments
        
        
        
    fix bugs()

proj2 Rpd(2018-09 to now):
    fix bugs(UI/call control/media process)
    
    
proj3 SDK based on rpm(2018-11 to):
    license develop:
    
RPC: remote procedure call
server A			server B
step1: establish a connect
step2: application in A tells underlying RPC framework how to connect to server B, such as host/ip/port/method name by endpoint URI(based on web service protocol stack) or query on the UDDI server or RMI registry 
step3: when application in server A starts to call, parameters will be transferred to server B, and these parameters will be changed to binary with serialize and marshal cause the network protocol is based on binary.
step4: when server B received the request, it did anti-serialize and anti-marshal to recover the data in memory, then get the appropriate method to call locally, and get the return value.
step5: return value will be sent to application in server A, should do serialize/marshal - send - receive - anti-serialize/marshal - send to application in A.

synchronization: caller does not return until get the result
asynchronization: caller return immediately 

block: the thread will be hang up when waiting the result
unblock: the thread continue do when waiting the result











